package com.enderio.machines.common.recipe;

import com.enderio.EnderIO;
import com.enderio.core.common.recipes.CountedIngredient;
import com.enderio.core.common.recipes.OutputStack;
import com.enderio.machines.common.blockentity.AlloySmelterBlockEntity;
import com.enderio.machines.common.blockentity.PrimitiveAlloySmelterBlockEntity;
import com.enderio.machines.common.init.MachineRecipes;
import com.enderio.machines.common.io.item.MultiSlotAccess;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.core.NonNullList;
import net.minecraft.core.RegistryAccess;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraft.world.level.Level;
import net.neoforged.neoforge.items.IItemHandlerModifiable;
import net.neoforged.neoforge.items.wrapper.RecipeWrapper;
import org.jetbrains.annotations.Nullable;

import java.util.List;

public class AlloySmeltingRecipe implements MachineRecipe<AlloySmeltingRecipe.ContainerWrapper> {

    private final List<CountedIngredient> inputs;
    private final ItemStack output;
    private final int energy;
    private final float experience;

    public AlloySmeltingRecipe(List<CountedIngredient> inputs, ItemStack output, int energy, float experience) {
        this.inputs = inputs;
        this.output = output;
        this.energy = energy;
        this.experience = experience;
    }

    /**
     * Get the inputs for the alloy smelting recipe.
     */
    public List<CountedIngredient> getInputs() {
        return inputs;
    }

    /**
     * Get the amount of experience generated by the recipe.
     */
    public float getExperience() {
        return experience;
    }

    @Override
    public int getBaseEnergyCost() {
        return energy;
    }

    @Override
    public NonNullList<Ingredient> getIngredients() {
        return NonNullList.of(Ingredient.EMPTY, inputs.stream().map(CountedIngredient::ingredient).toArray(Ingredient[]::new));
    }

    @Override
    public boolean matches(ContainerWrapper container, Level level) {
        boolean[] matched = new boolean[3];
        var slotAccess = container.getSlotAccess();

        // Iterate over the slots
        for (int i = 0; i < 3; i++) {
            // Iterate over the inputs
            for (int j = 0; j < 3; j++) {
                // If this ingredient has been matched already, continue
                if (matched[j]) {
                    continue;
                }

                var slotItem = slotAccess.get(i).getItemStack(container);

                if (j < inputs.size()) {
                    // If we expect an input, test we have a match for it.
                    if (inputs.get(j).test(slotItem)) {
                        matched[j] = true;
                    }
                } else if (slotItem.isEmpty()) {
                    // If we don't expect an input, make sure we have a blank for it.
                    matched[j] = true;
                }
            }
        }

        // If we matched all our ingredients, we win!
        for (int i = 0; i < 3; i++) {
            if (!matched[i]) {
                return false;
            }
        }

        return true;
    }

    @Override
    public List<OutputStack> craft(ContainerWrapper container, RegistryAccess registryAccess) {
         return List.of(OutputStack.of(output.copy()));
    }

    @Override
    public List<OutputStack> getResultStacks(RegistryAccess registryAccess) {
        return List.of(OutputStack.of(output.copy()));
    }


    @Override
    public RecipeSerializer<?> getSerializer() {
        return MachineRecipes.ALLOY_SMELTING.serializer().get();
    }

    @Override
    public RecipeType<?> getType() {
        return MachineRecipes.ALLOY_SMELTING.type().get();
    }

    /**
     * The recipe container.
     * This acts as additional context.
     */
    public static class ContainerWrapper extends RecipeWrapper {

        private final boolean isPrimitive;
        private int inputsTaken;

        public ContainerWrapper(boolean isPrimitive, IItemHandlerModifiable inv) {
            super(inv);
            this.isPrimitive = isPrimitive;
        }

        public MultiSlotAccess getSlotAccess() {
            // Instead of a bool we could just pass the slot accesses, but a bool is probably cheaper to do.
            return isPrimitive ? PrimitiveAlloySmelterBlockEntity.INPUTS : AlloySmelterBlockEntity.INPUTS;
        }

        public int getInputsTaken() {
            return inputsTaken;
        }

        public void setInputsTaken(int inputsTaken) {
            this.inputsTaken = inputsTaken;
        }
    }

    public static class Serializer implements RecipeSerializer<AlloySmeltingRecipe> {
        public static final Codec<AlloySmeltingRecipe> CODEC = RecordCodecBuilder.create(inst -> inst.group(
                CountedIngredient.CODEC.listOf().fieldOf("inputs").forGetter(AlloySmeltingRecipe::getInputs),
                ItemStack.CODEC.fieldOf("result").forGetter(obj -> obj.output),
                Codec.INT.fieldOf("energy").forGetter(obj -> obj.energy),
                Codec.FLOAT.fieldOf("experience").forGetter(AlloySmeltingRecipe::getExperience))
            .apply(inst, AlloySmeltingRecipe::new));

        @Override
        public Codec<AlloySmeltingRecipe> codec() {
            return CODEC;
        }

        @Override
        @Nullable
        public AlloySmeltingRecipe fromNetwork(FriendlyByteBuf buffer) {
            List<CountedIngredient> ingredients = buffer.readList(CountedIngredient::fromNetwork);
            ItemStack result = buffer.readItem();
            int energy = buffer.readInt();
            float experience = buffer.readFloat();
            return new AlloySmeltingRecipe( ingredients, result, energy, experience);

        }

        @Override
        public void toNetwork(FriendlyByteBuf buffer, AlloySmeltingRecipe recipe) {
            try {
                buffer.writeCollection(recipe.inputs, (buf, ing) -> ing.toNetwork(buf));
                buffer.writeItem(recipe.output);
                buffer.writeInt(recipe.energy);
                buffer.writeFloat(recipe.experience);
            } catch (Exception ex) {
                EnderIO.LOGGER.error("Error writing alloy smelting recipe to packet.", ex);
                throw ex;
            }
        }
    }
}
